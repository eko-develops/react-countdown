{"version":3,"sources":["App.js","index.js"],"names":["App","useState","seconds","setSeconds","isRunning","setIsRunning","isFinished","setIsFinished","number","setNumber","useEffect","console","log","intervalId","window","setInterval","clearInterval","className","Container","align","Typography","variant","style","fontSize","TextField","label","onChange","event","target","value","Button","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"8QAkHeA,MA9Gf,WAEE,MAA8BC,mBAAS,IAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KACA,EAAkCF,oBAAS,GAA3C,mBAAOG,EAAP,KAAkBC,EAAlB,KACA,EAAoCJ,oBAAS,GAA7C,mBAAOK,EAAP,KAAmBC,EAAnB,KACA,EAA4BN,mBAAS,IAArC,mBAAOO,EAAP,KAAeC,EAAf,KAwEA,OAtEAC,qBAAW,WAGT,GAFAC,QAAQC,IAAI,iBAETR,EAAU,CACT,GAAGF,EAAU,EAAE,CAIb,IAAMW,EAAaC,OAAOC,aAAa,WAErCJ,QAAQC,IAAI,wBAAyBV,GAIrCC,GAAY,SAAAD,GAAO,OAAIA,EAAU,OAEhC,KAEH,OAAO,kBAAMY,OAAOE,cAAcH,IAiBlCR,GAAa,GACbE,GAAc,GACdI,QAAQC,IAAI,oBAAqBR,GACjCO,QAAQC,IAAI,qBAAsBN,MAKxC,CAACF,EAAWF,IA4BZ,qBAAKe,UAAU,MAAf,SACE,eAACC,EAAA,EAAD,CAAWC,MAAM,SAASF,UAAU,UAApC,UACE,cAACG,EAAA,EAAD,CAAYC,QAAQ,KAApB,mCACA,eAACD,EAAA,EAAD,CAAYC,QAAQ,KAAKJ,UAAU,gBAAnC,UAEGf,EAGCI,EAAa,mBAAGgB,MAAO,CAACC,SAAS,QAApB,6BAAmD,MAIlE,cAACC,EAAA,EAAD,CACAC,MAAM,iBAENC,SArBe,SAACC,GACtBlB,EAAUkB,EAAMC,OAAOC,OACvBlB,QAAQC,IAAI,yBAA0Be,EAAMC,OAAOC,UAsB/C,sBAAKZ,UAAU,iBAAf,UAGKb,EAEH,cAAC0B,EAAA,EAAD,CAAQT,QAAQ,YAAYJ,UAAU,eAAec,QAAU,WAAQ1B,GAAa,IAApF,mBADA,cAACyB,EAAA,EAAD,CAAQT,QAAQ,YAAYJ,UAAU,eAAec,QApCzC,WAClB5B,EAAWK,GACXH,GAAa,GACbM,QAAQC,IAAI,qBAAsBJ,GAClCG,QAAQC,IAAI,wBAAwB,IAgC9B,kBAGA,cAACkB,EAAA,EAAD,CAAQT,QAAQ,OAAOU,QAhDX,WAClB5B,EAAWK,GACXH,GAAa,GACbE,GAAc,GACdI,QAAQC,IAAI,qBAAsBJ,GAClCG,QAAQC,IAAI,wBAAwB,IA2C9B,4BCtGVoB,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.b8151c2d.chunk.js","sourcesContent":["import './App.css';\r\nimport { Button, Typography, Container, TextField } from '@material-ui/core'\r\nimport { useState, useEffect } from 'react'\r\n\r\nfunction App() {\r\n\r\n  const [seconds, setSeconds] = useState(\"\"); //set the state of seconds on first render\r\n  const [isRunning, setIsRunning] = useState(false);  //handles if the timer is running or paused\r\n  const [isFinished, setIsFinished] = useState(false);  //set the state if the timer is finished or not\r\n  const [number, setNumber] = useState(\"\"); //set the state for the initial value of the input field\r\n\r\n  useEffect( () => {\r\n    console.log('useEffect ran'); //TEST\r\n\r\n    if(isRunning){  //as long as isRunning is true, we will continue to call the interval\r\n        if(seconds > 0){  //if the timer is not over yet\r\n\r\n          //https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\r\n          //returns an interval ID which uniquely identifies the interval, so you can remove it later by calling clearInterval()\r\n          const intervalId = window.setInterval( () => {\r\n\r\n            console.log('a second has passed..', seconds);  //TEST\r\n\r\n            //useState setter functions have a hidden callback function that remembers the previous value.\r\n            //if we do not use this syntax, the state will remain the same as the FIRST render of the app.\r\n            setSeconds( seconds => seconds - 1 );\r\n\r\n          }, 1000); //for every 1 second, this interval will run\r\n\r\n          return () => window.clearInterval(intervalId); //clean up function. runs right before the useEffect. read more below\r\n\r\n          //About Clean Up Functions\r\n          // When you return a function inside of the useEffect, when the useEffect runs again, it will call the clean up function.\r\n          // Also runs when the component is about to be unmounted.\r\n    \r\n          //How the Clean Up Function Works in This Project.\r\n          // Initially when the app renders, isRunning will be set to false. When clicking on the start button, isRunning will become true\r\n          // and the useEffect will fire because isRunning is a dependency. From there the callback in setInterval will be called every 1 second.\r\n          // Within that if statement, there is the clean up function that the useEffect hook will remember on next render or when the component is about to be unmounted.\r\n          // On every fire of the useEffect, the clean up function will be called and clear the interval when the component is about to mount and unmounts.\r\n    \r\n          //Why use the clean up function?\r\n          // Using the clean up function will allow us to cut down on lines of code and also decrease the amount of state variables we need. If we did not \r\n          // use a clean up function, we would need a state variable that contains the return value of setInterval and then clearInterval in an else statement.\r\n          \r\n        } else {  //if the timer is over, we'll \r\n          setIsRunning(false);\r\n          setIsFinished(true);\r\n          console.log(\"isRunning set to:\", isRunning);  //TEST\r\n          console.log(\"isFinished set to:\", isFinished);  //TEST\r\n          \r\n        }\r\n    }\r\n\r\n  },[isRunning, seconds]); //the useEffect will only run on first render and when isRunning changes (pre-release)\r\n                           //updated note: we need to include seconds as a dependency so we can stop the timer at 0\r\n\r\n\r\n  //This function handles the reset button and reverts the timer back to 'default' settings\r\n  const handleReset = () => { \r\n    setSeconds(number);\r\n    setIsRunning(false);\r\n    setIsFinished(false);\r\n    console.log(\"setting seconds to\", number);  //TEST\r\n    console.log(\"setting isRunning to\", false)  //TEST\r\n  }\r\n  \r\n  //This function starts the timer\r\n  const handleStart = () => {\r\n    setSeconds(number);\r\n    setIsRunning(true);\r\n    console.log(\"setting seconds to\", number);  //TEST\r\n    console.log(\"setting isRunning to\", true);  //TEST\r\n  }\r\n\r\n  //This function is used to set the value entered in the input box\r\n  const handleOnChange = (event) => { //the onChange prop automatically allows us to use the event object\r\n    setNumber(event.target.value);\r\n    console.log(\"number has been set to\", event.target.value);  //TEST\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Container align=\"center\" className=\"wrapper\">\r\n        <Typography variant=\"h6\" >React Countdown Timer</Typography>\r\n        <Typography variant=\"h3\" className=\"timer-display\" >\r\n          \r\n          {seconds}\r\n\r\n          {/* only display the timer is finished text when the timer is actually finished */}\r\n          { isFinished ? <p style={{fontSize:'1rem'}}>Countdown Done!</p> : \"\"}\r\n\r\n        </Typography>\r\n\r\n          <TextField\r\n          label=\"Enter a Number\"\r\n          //we'll use the onChange event handler to capture the text/value in the input field and handle it in a  handleOnChange function\r\n          onChange={handleOnChange}\r\n          />\r\n\r\n        <div className=\"button-wrapper\">\r\n          {/* Good React buttons only toggle boolean values. think of buttons like switches.\r\n          Toggle between buttons depending if the timer is running or not running */}\r\n          { !isRunning ? \r\n          <Button variant=\"contained\" className=\"start-Button\" onClick={handleStart}>Play</Button> :\r\n          <Button variant=\"contained\" className=\"pause-Button\" onClick={ () => { setIsRunning(false)} }>Pause</Button>\r\n          }\r\n          <Button variant=\"text\" onClick={handleReset} >Reset</Button>\r\n        </div>\r\n      </Container>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}